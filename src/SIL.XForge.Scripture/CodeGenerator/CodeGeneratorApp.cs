using CommandLine;
using System;
using System.Collections.Generic;
using System.IO;
using NJsonSchema;
using NJsonSchema.CodeGeneration.CSharp;
using NJsonSchema.CodeGeneration.TypeScript;
using System.Reflection;

namespace CodeGenerator
{
    class CodeGeneratorApp
    {
        static void Main(string[] args)
        {
            Parser.Default.ParseArguments<CommandLineOptions>(args)
                   .WithParsed<CommandLineOptions>(o =>
                   {
                       GenerateClassesFromSchema(o.Schema, o.Typescript, o.CSharp, o.JsonApi);
                   });
        }

        private static void GenerateClassesFromSchema(string schema, string typescript, string csharp, string jsonApi)
        {
            if (!File.Exists(schema))
            {
                Console.WriteLine($"Schema file: {schema} not found.");
                return;
            }
            if (!Directory.Exists(Path.GetDirectoryName(typescript)))
            {
                Console.WriteLine($"Typescript destination directory {typescript} not found.");
                return;
            }
            if (!Directory.Exists(Path.GetDirectoryName(csharp)))
            {
                Console.WriteLine($"C# destination directory {csharp} not found.");
                return;
            }
            if (!Directory.Exists(Path.GetDirectoryName(jsonApi)))
            {
                Console.WriteLine($"Directory {Path.GetDirectoryName(jsonApi)} for jsonapi file not found.");
                return;
            }

            // test abstract
            var testSchema = JsonSchema4.FromTypeAsync(typeof(TestAbstractType)).Result;
            Console.Write(testSchema.ToJson());

            // Load the schema from the file
            var sourceSchema = JsonSchema4.FromJsonAsync(File.ReadAllText(schema)).Result;
            var handWrittenBaseClasses = new Dictionary<string, string>();
            handWrittenBaseClasses["Resource"] = "SIL.XForge.Models";
            #region Generate C# model objects
            var csharpSettings = new CSharpGeneratorSettings()
            {
                Namespace = "SIL.XForge.Scripture.Models",
                GenerateJsonMethods = false,
                ClassStyle = CSharpClassStyle.Poco,
                ExcludedTypeNames = new List<string>(handWrittenBaseClasses.Keys).ToArray()
            };
            var generator = new CSharpGenerator(sourceSchema, csharpSettings);
            var csharpContents = generator.GenerateFile();
            AddImportsForHandwrittenClasses(ref csharpContents, handWrittenBaseClasses.Values);
            File.WriteAllText(csharp, csharpContents);
            #endregion

            #region Generate Typescript model objects
            // Get all the types defined in the schema
            var definedTypes = new List<string>();
            foreach (var type in sourceSchema.Definitions)
            {
                definedTypes.Add(type.Key);
            }
            
            var typescriptSettings = new TypeScriptGeneratorSettings()
            {
                Namespace = "SIL.XForge.Scripture.Models",
                ExcludedTypeNames = new List<string>(handWrittenBaseClasses.Keys).ToArray(),
                ExtensionCode = "import {Resource, ResourceRef} from \"../../../xforge-common/models/resource\";",
                TemplateDirectory = "../../../Templates",
                ConvertConstructorInterfaceData = false,
                // skip generating interfaces for the defined types
                GenerateConstructorInterface = false,
                MarkOptionalProperties = true
            };

            var tsGenerator = new TypeScriptGenerator(sourceSchema, typescriptSettings);
            var tsContents = tsGenerator.GenerateFile();
            File.WriteAllText(typescript, tsContents);
            #endregion
            GenerateJsonModelIncludeFile(schema, typescript, definedTypes, new List<string>(handWrittenBaseClasses.Keys), jsonApi, sourceSchema);
        }

        private static void GenerateJsonModelIncludeFile(string schema, string typescript, List<string> importTypes, List<string> handWrittenBaseClasses, string jsonApi, JsonSchema4 sourceSchema)
        {
            #region Generate injectable model include typescript file
            var classComment = $"//----------------------" +
                               $"// <auto-generated>" +
                               $"//    Generated using {Assembly.GetExecutingAssembly().FullName} from {schema}" +
                               $"// </auto-generated>" +
                               $"//----------------------" +
                               $"{Environment.NewLine}";
            string imports = string.Empty;
            foreach(var type in importTypes)
            {
                if (handWrittenBaseClasses.Contains(type))
                    continue;
                imports += $"import {{{type}}} from '{typescript.Substring(0, typescript.Length - 3)}';{Environment.NewLine}";
            }
            var config = string.Empty;
            var fileContents = $"{classComment}{Environment.NewLine}" +
                               $"{imports}{Environment.NewLine}" +
                               $"// All resource, resource ref, and realtime doc types should be added to schema and generated into this config{Environment.NewLine}" +
                               $"{config}{Environment.NewLine}";
            File.WriteAllText(jsonApi, fileContents);
            #endregion
        }

        private static void AddImportsForHandwrittenClasses(ref string csharpContents, IEnumerable<string> importsNeeded)
        {
            string importsString = string.Empty;
            foreach(var import in importsNeeded)
            {
                importsString += $"using {import};{Environment.NewLine}";
            }
            csharpContents = csharpContents.Replace("namespace SIL.XForge.Scripture.Models", $"{importsString}{Environment.NewLine}namespace SIL.XForge.Scripture.Models");
        }
    }

    abstract class TestAbstractType
    {
        public const int test = 5;
    }
}
